Below is a revised and more detailed breakdown of each of the 10 development stages. For each stage, you will see:
	•	Files to Create or Modify: Specific filenames and their locations in the ./src directory.
	•	Components to Implement: Which React components to create, what they do, and where to place them.
	•	Design & Visual Details: Guidance on how the UI should look based on the provided design plan.
	•	Acceptance Criteria Recap: What needs to work at the end of the stage.

All file paths assume the project’s root is where vite.config.js lives, and ./src is the main code directory.

Stage 1: Project Setup & Base Configuration

Files to Create or Modify:
	•	At project root:
	•	package.json (auto-generated by Vite init)
	•	firebase.json (Firebase hosting config)
	•	tailwind.config.cjs, postcss.config.cjs (Tailwind and PostCSS configs)
	•	In ./src/:
	•	main.tsx (Vite entry point)
	•	app/App.tsx: Root component for the application
	•	app/router.tsx: For React Router configuration
	•	app/Providers.tsx: For wrapping application-level providers (React Query, etc.)
	•	styles/globals.css: Add @tailwind base; @tailwind components; @tailwind utilities;
	•	lib/firebase/config.ts: Firebase initialization (import and initialize Firebase)
	•	lib/firebase/auth.ts: Basic auth utilities (placeholder for now)
	•	Directory structure setup:
	•	features/, components/, pages/, lib/, styles/, and types/ directories as per plan.
	•	Initially, these can have placeholder .gitkeep or simple index files.

Components to Implement:
	•	For now, just App.tsx (simple placeholder rendering a “Hello World”).
	•	No domain-specific UI components yet.

Design & Visual Details:
	•	Confirm Tailwind is working by styling a basic <div className="text-red-500">Hello World</div> in App.tsx.
	•	No finalized design yet, just a functional test.

Acceptance Criteria:
	•	Project runs (npm run dev) without errors.
	•	Tailwind styling works.
	•	Firebase is initialized and ready for future use.
	•	Basic route setup (even if just "/" and "/login" placeholders).

Stage 2: Authentication (Google Sign-In + Whitelist Check)

Files to Create or Modify:
	•	pages/SignInPage.tsx: A page for Google Sign-In.
	•	features/auth/hooks/useAuth.ts: Manages auth state and checks for whitelist.
	•	features/auth/components/GoogleSignInButton.tsx: Button that triggers Firebase Google Sign-In.
	•	features/auth/data/authQueries.ts: Whitelist check function.
	•	lib/firebase/auth.ts: Implement signInWithGoogle(), signOut(), and user state listener.

Components to Implement:
	•	GoogleSignInButton.tsx: A button (using components/ui/button.tsx from shadcn/ui) that initiates signInWithGoogle().
	•	SignInPage.tsx: Centered layout with the GoogleSignInButton and an error message if not whitelisted. Uses a very simple AuthLayout.tsx (create this too in app/layouts/).

Design & Visual Details:
	•	Sign-In Screen:
	•	White background.
	•	Centered GoogleSignInButton with the app name “MyBiz” text above it.
	•	Error message in red text if user not whitelisted.
	•	Use Tailwind classes to center content (e.g., className="flex flex-col items-center justify-center h-screen").

Acceptance Criteria:
	•	Clicking “Sign in with Google” signs user in if whitelisted, otherwise shows error.
	•	Logout function available (can be placed temporarily in App.tsx or a temp user menu).
	•	Local dev override: if NODE_ENV=development, useAuth.ts can return a mock user to skip login.

Stage 3: Global Layout & Navigation

Files to Create or Modify:
	•	app/layouts/RootLayout.tsx: Top-level layout (if needed).
	•	app/layouts/DashboardLayout.tsx: For main authenticated pages.
	•	app/layouts/AuthLayout.tsx: Minimal layout for sign-in page.
	•	components/navigation/Header.tsx: Header with app name and user avatar.
	•	components/navigation/TabNavigation.tsx: Tabs for Customers, Orders, etc.
	•	components/navigation/UserMenu.tsx: A placeholder with a logout option.

Components to Implement:
	•	Header.tsx:
	•	Show “MyBiz” on the left, user avatar on the right.
	•	TabNavigation.tsx:
	•	Horizontal tabs: “Customers”, “Orders”, “Products”, “Job Descriptions”, “Offers”, “Reports”.
	•	Highlight the active tab using Tailwind classes and shadcn/ui button or tab components.
	•	UserMenu.tsx:
	•	A simple dropdown under user avatar with “Logout” option.

Design & Visual Details:
	•	Header:
	•	White background, slight shadow.
	•	Left: App logo/name in bold dark grey (#333).
	•	Right: user avatar (a circle with user initial or a generic icon).
	•	Tabs:
	•	Under the header, horizontally scrollable on mobile.
	•	Selected tab: blue-grey (#607D8B) underline or background tint.
	•	Responsive:
	•	On mobile, tabs might need horizontal scrolling with overflow-x-auto.
	•	On desktop, tabs fit in a single row.

Acceptance Criteria:
	•	After sign-in, user sees DashboardLayout with header + tabs.
	•	Clicking tabs changes route.
	•	Logout works from user menu.

Stage 4: Customers List View (US-2)

Files to Create or Modify:
	•	pages/CustomersPage.tsx: Renders the customer list and search bar.
	•	features/customers/data/customersQueries.ts: Firestore queries to fetch customers.
	•	features/customers/hooks/useCustomers.ts: Hook to fetch and cache customers.
	•	features/customers/components/CustomerList.tsx: Lists customers.
	•	components/common/SearchBar.tsx: Reusable search input.

Components to Implement:
	•	CustomerList.tsx:
	•	Iterates over a list of customers and displays each using a CustomerCard.tsx component.
	•	CustomerCard.tsx:
	•	Shows name, businessName, and basic info (like phone/email icons).
	•	SearchBar.tsx:
	•	An input with a search icon, triggers a filter function in CustomersPage.

Design & Visual Details:
	•	Customers Page:
	•	Top: SearchBar (a simple input with Tailwind styling).
	•	Below: A vertical list of customers. Each “card”:
	•	Larger bold text for customer name.
	•	Smaller, grey text for business name.
	•	Minimal metrics icons (e.g., a phone icon from Lucide).
	•	On desktop, can be a table or grid, but for now keep it simple.

Acceptance Criteria:
	•	Searching filters customer list.
	•	Customers load from Firestore and show a loading spinner if fetching.
	•	Pagination or infinite scroll: a “Load More” button at the bottom if needed.

Stage 5: Customer Details & Editing (US-3)

Files to Create or Modify:
	•	pages/CustomerDetailsPage.tsx: Route like /customers/:id.
	•	features/customers/components/CustomerDetails.tsx: Detailed view of a single customer.
	•	features/customers/components/CustomerForm.tsx: Form for editing/adding customer info.
	•	features/customers/hooks/useCustomerForm.ts: Manages form state/validation.
	•	features/customers/components/CustomerContacts.tsx & CustomerAddresses.tsx: Subcomponents for contact and address info if needed.

Components to Implement:
	•	CustomerDetails.tsx:
	•	Display full info: name, business name, primary contact, addresses.
	•	Show a list of recent orders (placeholder for now).
	•	An “Edit” button that opens the CustomerForm in a modal or navigates to an edit view.
	•	CustomerForm.tsx:
	•	Fields: name, business name, email, phone, addresses (with “Set as primary” checkboxes).
	•	Save/Cancel buttons.
	•	Validation messages for required fields and proper formats.

Design & Visual Details:
	•	Customer Details:
	•	On mobile: a clean single-column view with headings for each section.
	•	On desktop: possibly a two-column layout (name on left, contacts on right).
	•	Edit mode can be a modal: use dialog from shadcn/ui and Tailwind to create a neat form overlay.
	•	Primary contact/address indicated with a small label or star icon.

Acceptance Criteria:
	•	Clicking a customer in the list navigates to their detail page.
	•	Edit button shows form, updates appear after saving.
	•	Proper error messages on invalid input.

Stage 6: Order Creation & Listing (US-4, US-5)

Files to Create or Modify:
	•	pages/OrdersPage.tsx: Displays orders list and toggle to calendar view.
	•	pages/OrderDetailsPage.tsx: Detailed view of an order.
	•	features/orders/data/ordersQueries.ts: Firestore queries for orders.
	•	features/orders/hooks/useOrders.ts, useOrderCalculations.ts: For fetching/filtering and price calculations.
	•	features/orders/components/OrderList.tsx, OrderCalendar.tsx: Two different views of orders.
	•	features/orders/components/OrderForm.tsx: Multi-step form for new orders.
	•	features/orders/components/OrderDetails.tsx: Detailed view of an existing order.

Components to Implement:
	•	OrderList.tsx:
	•	Similar to CustomerList but shows date, customer name, product, price, and status.
	•	OrderForm.tsx:
	•	Steps: Select Customer (dropdown), Choose Job, Select Product & Quantity, Apply price/discount logic.
	•	Real-time totals and “Save as draft” or “Complete” buttons.
	•	OrderCalendar.tsx:
	•	Simple calendar display (even a basic grid) to show orders by date. Initially can be minimal.

Design & Visual Details:
	•	Orders Page:
	•	A toggle (button group) at the top to switch between List and Calendar view.
	•	On mobile, default to list view for simplicity.
	•	Order Form:
	•	Use vertical stacked inputs on mobile screens.
	•	Show totals at the bottom in a bold font.
	•	“+ Order” button on the OrdersPage at bottom-right (floating) or top.

Acceptance Criteria:
	•	Orders fetch correctly and display in list format.
	•	Can create a new order via the form and see it appear in the list.
	•	Filter by customer/date/status works (add a basic filter panel or dropdown).
	•	Calendar view (basic) shows orders by date.

Stage 7: Product & Job Descriptions Management (US-6)

Files to Create or Modify:
	•	pages/ProductsPage.tsx: For viewing products.
	•	pages/JobDescriptionsPage.tsx: For viewing job descriptions.
	•	features/products/data/productsQueries.ts: CRUD for products.
	•	features/products/data/jobDescriptionsQueries.ts: CRUD for job descriptions.
	•	features/products/hooks/useProducts.ts, useJobDescriptions.ts: Fetching and managing product/job data.
	•	features/products/components/ProductList.tsx, ProductForm.tsx: Manage products.
	•	features/products/components/JobDescriptionList.tsx, JobDescriptionForm.tsx: Manage job descriptions.

Components to Implement:
	•	ProductList.tsx:
	•	Displays product name, description, active/inactive toggle.
	•	ProductForm.tsx:
	•	Fields for name, description, base price.
	•	JobDescriptionList.tsx and JobDescriptionForm.tsx:
	•	Similar CRUD pattern.

Design & Visual Details:
	•	Simple list format similar to Customers.
	•	A “+ Product” or “+ Job Description” button at the top to add new entries.
	•	Use a toggle switch (shadcn/ui switch component) for active/inactive.

Acceptance Criteria:
	•	Can view, add, edit, and inactivate products and job descriptions.
	•	Changes reflect in order creation dropdowns (if a product is inactive, it shouldn’t appear as an option).

Stage 8: Price Management & Special Offers (US-7, US-8)

Files to Create or Modify:
	•	Potentially features/products/data/pricingQueries.ts (for specific price overrides).
	•	features/offers/data/offersQueries.ts: For offer CRUD.
	•	features/offers/hooks/useOffers.ts, useOfferCalculations.ts: Manage and apply offers.
	•	features/offers/components/OfferList.tsx, OfferForm.tsx, OfferStatus.tsx.

Components to Implement:
	•	ProductPricing.tsx:
	•	A table or list allowing selection of customer-job-product combo and setting a price.
	•	OfferList.tsx:
	•	List all offers: name, date range, discount type/value, active status.
	•	OfferForm.tsx:
	•	Fields: Offer name, start/end date pickers, discount type (percentage/fixed), discount value, customer selection.

Design & Visual Details:
	•	Pricing Management:
	•	A simple list or table: columns for customer, job, product, and a numeric input for price.
	•	Offers Page:
	•	Similar to other lists with an “+ Offer” button.
	•	Show badges for active/upcoming/expired.
	•	Date pickers styled with Tailwind and shadcn/ui (e.g., Calendar or DatePicker component if available).

Acceptance Criteria:
	•	Price overrides can be created and fetched, applied during order creation.
	•	Offers can be created, are automatically applied when conditions match.
	•	In the order form, if an offer applies, show the discounted price.

Stage 9: Reporting & Basic Analytics (US-9, US-10)

Files to Create or Modify:
	•	pages/ReportsPage.tsx: Main reports interface.
	•	features/reports/data/reportsQueries.ts: Aggregation queries (mock or approximate at first).
	•	features/reports/hooks/useReports.ts, useChartData.ts: Data fetching and formatting for charts.
	•	features/reports/components/ReportDashboard.tsx, RevenueChart.tsx, CustomerMetrics.tsx, ProductMetrics.tsx, ExportControls.tsx.

Components to Implement:
	•	RevenueChart.tsx and CustomerMetrics.tsx:
	•	Use components/charts/LineChart.tsx or BarChart.tsx.
	•	ExportControls.tsx:
	•	Buttons/icons for exporting PDF/CSV (functionality can be mocked).
	•	Filter panel (use components/common/FilterPanel.tsx):
	•	Date range pickers, dropdown for customer/product filters.

Design & Visual Details:
	•	Show a line chart for revenue trends.
	•	Show a bar chart for top products/customers.
	•	Clean, card-based layout:
	•	A top filter bar or slide-over panel.
	•	Light grey background with white cards for charts.

Acceptance Criteria:
	•	Reports page shows charts with data from Firestore (or minimal mock aggregator for now).
	•	Filters adjust chart data.
	•	Export buttons visible (even if not fully functional yet).

Stage 10: Final Polishing, Responsive & Accessible Design, Error Handling

Files to Create or Modify:
	•	styles/themes.css: Fine-tune colors, spacing.
	•	Add ARIA attributes to components where needed (in their respective files).
	•	Implement error boundaries: app/ErrorBoundary.tsx.
	•	Improve useAuth.ts, useCustomers.ts, etc. with error handling logic.

Components to Adjust:
	•	Add a global LoadingSpinner.tsx in components/common if not already done.
	•	Add ConfirmationDialog.tsx in components/common for delete confirmations.
	•	Ensure all forms have proper labels and accessible hints.

Design & Visual Details:
	•	Check color contrast using something like #333 on white backgrounds.
	•	Ensure all buttons have hover/focus states clearly visible.
	•	Make sure forms have readable labels and error messages for screen readers.
	•	On desktop, utilize available width (e.g., two-column layouts where appropriate).
	•	Finalize consistent padding and spacing.

Acceptance Criteria:
	•	App is fully responsive and accessible.
	•	Meaningful error messages and loading states everywhere.
	•	No console errors, good Lighthouse accessibility score.
	•	All user stories from the product plan are completed.

After completing these 10 stages, the developer will have a fully implemented application with all the specified features, designs, and architectural guidelines. Each step’s detailed file and component breakdown ensures clarity on what needs to be built and how.